import { useState, useEffect, useCallback, useRef } from 'react';
import { useAuth } from '../../hooks/useAuth';
import { StreakService } from '../services/StreakService';
import { StreakData, StreakModalData } from '../types';

// Import du contexte FirstConnection pour √©viter les conflits de modals
let useFirstConnection: (() => { showQuestionnaire: boolean }) | null = null;
try {
  const firstConnectionModule = require('../../../app/contexts/FirstConnectionContext');
  useFirstConnection = firstConnectionModule.useFirstConnection;
} catch (error) {
  // Le contexte n'est pas disponible, on continue sans
  console.log('FirstConnectionContext non disponible dans useStreak');
}

// Cache global pour √©viter les v√©rifications multiples entre diff√©rentes instances du hook
let globalEligibilityCache: {
  userId: string | null;
  timestamp: number;
  isChecking: boolean;
  hasCheckedToday: boolean;
} = {
  userId: null,
  timestamp: 0,
  isChecking: false,
  hasCheckedToday: false
};

// Dur√©e de validit√© du cache (5 minutes)
const CACHE_VALIDITY_MS = 5 * 60 * 1000;

export const useStreak = () => {
  const { user } = useAuth();
  const [streakData, setStreakData] = useState<StreakData | null>(null);
  const [modalData, setModalData] = useState<StreakModalData>({
    visible: false,
    streakCount: 0,
    dodjiEarned: 0,
    title: '',
    description: ''
  });
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  // Utiliser useRef pour suivre l'√©tat de connexion pr√©c√©dent
  const previousUserRef = useRef<string | null>(null);
  const hasCheckedForNewLoginRef = useRef(false);
  const isCheckingEligibilityRef = useRef(false); // Protection contre les appels multiples

  // V√©rifier si le questionnaire de premi√®re connexion est visible
  let isQuestionnaireVisible = false;
  try {
    if (useFirstConnection) {
      const firstConnectionContext = useFirstConnection();
      isQuestionnaireVisible = firstConnectionContext.showQuestionnaire;
    }
  } catch (error) {
    // Ignorer l'erreur si le contexte n'est pas disponible
  }

  /**
   * V√©rifie si le cache global est valide pour l'utilisateur actuel
   */
  const isGlobalCacheValid = useCallback((userId: string) => {
    const now = Date.now();
    return (
      globalEligibilityCache.userId === userId &&
      (now - globalEligibilityCache.timestamp) < CACHE_VALIDITY_MS &&
      globalEligibilityCache.hasCheckedToday
    );
  }, []);

  /**
   * Met √† jour le cache global
   */
  const updateGlobalCache = useCallback((userId: string, hasChecked: boolean) => {
    globalEligibilityCache = {
      userId,
      timestamp: Date.now(),
      isChecking: false,
      hasCheckedToday: hasChecked
    };
  }, []);

  /**
   * V√©rifie l'√©ligibilit√© au streak (sans donner les r√©compenses)
   */
  const checkStreakEligibility = useCallback(async () => {
    if (!user) {
      setError('Utilisateur non connect√©');
      return null;
    }

    // V√©rifier le cache global d'abord
    if (isGlobalCacheValid(user.uid)) {
      console.log('üéØ useStreak: Cache global valide, v√©rification ignor√©e');
      return null;
    }

    // √âviter les appels multiples simultan√©s (protection locale)
    if (isCheckingEligibilityRef.current) {
      console.log('üéØ useStreak: V√©rification locale d√©j√† en cours, ignor√©');
      return null;
    }

    // √âviter les appels multiples simultan√©s (protection globale)
    if (globalEligibilityCache.isChecking) {
      console.log('üéØ useStreak: V√©rification globale d√©j√† en cours, ignor√©');
      return null;
    }

    try {
      isCheckingEligibilityRef.current = true;
      globalEligibilityCache.isChecking = true;
      setLoading(true);
      setError(null);
      console.log('üéØ useStreak: V√©rification de l\'√©ligibilit√© au streak pour:', user.uid);
      
      const result = await StreakService.checkStreakEligibility(user.uid);
      setStreakData(result);

      console.log('üéØ useStreak: R√©sultat de l\'√©ligibilit√©:', result);

      // Afficher le modal si c'est un nouveau jour de streak avec r√©compense
      if (result.isNewStreakDay && result.todayReward && result.totalDodjiEarned > 0) {
        console.log('üéØ useStreak: ‚úÖ CONDITIONS REMPLIES - Affichage du modal de r√©compense');
        console.log('üéØ useStreak: - isNewStreakDay:', result.isNewStreakDay);
        console.log('üéØ useStreak: - todayReward:', result.todayReward);
        console.log('üéØ useStreak: - totalDodjiEarned:', result.totalDodjiEarned);
        
        // V√©rifier qu'aucun modal n'est d√©j√† affich√© ET que le questionnaire n'est pas visible
        if (!modalData.visible && !isQuestionnaireVisible) {
          const newModalData = {
            visible: true,
            streakCount: result.currentStreak,
            dodjiEarned: result.totalDodjiEarned,
            title: result.todayReward.title,
            description: result.todayReward.description,
            isNewRecord: result.currentStreak > (streakData?.currentStreak || 0)
          };
          console.log('üéØ useStreak: Donn√©es du modal √† afficher:', newModalData);
          setModalData(newModalData);
        } else {
          if (isQuestionnaireVisible) {
            console.log('üéØ useStreak: Questionnaire de premi√®re connexion visible, modal de streak report√©');
          } else {
            console.log('üéØ useStreak: Modal d√©j√† visible, ignor√©');
          }
        }
      } else {
        console.log('üéØ useStreak: ‚ùå CONDITIONS NON REMPLIES - Pas de modal √† afficher');
        console.log('üéØ useStreak: - isNewStreakDay:', result.isNewStreakDay);
        console.log('üéØ useStreak: - todayReward:', result.todayReward);
        console.log('üéØ useStreak: - totalDodjiEarned:', result.totalDodjiEarned);
        console.log('üéØ useStreak: - Conditions d√©taill√©es:', {
          isNewStreakDay: result.isNewStreakDay,
          hasTodayReward: !!result.todayReward,
          hasReward: result.totalDodjiEarned > 0
        });
      }

      // Mettre √† jour le cache global
      updateGlobalCache(user.uid, true);

      return result;
    } catch (err: any) {
      console.error('üéØ useStreak: Erreur lors de la v√©rification de l\'√©ligibilit√©:', err);
      setError(err.message || 'Erreur lors de la v√©rification du streak');
      return null;
    } finally {
      setLoading(false);
      isCheckingEligibilityRef.current = false;
      globalEligibilityCache.isChecking = false;
    }
  }, [user, streakData?.currentStreak, isGlobalCacheValid, updateGlobalCache]);

  /**
   * R√©cup√®re les donn√©es de streak actuelles
   */
  const getCurrentStreak = useCallback(async () => {
    if (!user) {
      setError('Utilisateur non connect√©');
      return null;
    }

    try {
      setLoading(true);
      setError(null);
      const result = await StreakService.getCurrentStreak(user.uid);
      setStreakData(result);
      return result;
    } catch (err: any) {
      setError(err.message || 'Erreur lors de la r√©cup√©ration du streak');
      return null;
    } finally {
      setLoading(false);
    }
  }, [user]);

  /**
   * R√©clame les r√©compenses du streak
   */
  const claimReward = useCallback(async () => {
    if (!user || !streakData) {
      setError('Aucune r√©compense √† r√©clamer');
      return false;
    }

    try {
      setLoading(true);
      setError(null);
      console.log('üéØ useStreak: R√©clamation des r√©compenses pour:', user.uid);
      
      await StreakService.claimStreakReward(user.uid, streakData);
      
      console.log('üéØ useStreak: R√©compenses r√©clam√©es avec succ√®s');
      
      // Fermer le modal apr√®s avoir r√©clam√© les r√©compenses
      setModalData(prev => ({ ...prev, visible: false }));
      
      // Marquer qu'on a d√©j√† v√©rifi√© et trait√© le streak aujourd'hui
      hasCheckedForNewLoginRef.current = true;
      
      // Mettre √† jour le cache global pour indiquer que le streak a √©t√© trait√©
      updateGlobalCache(user.uid, true);
      
      // Rafra√Æchir les donn√©es de streak pour refl√©ter les changements
      console.log('üéØ useStreak: Rafra√Æchissement des donn√©es apr√®s r√©clamation');
      const updatedStreakData = await getCurrentStreak();
      if (updatedStreakData) {
        setStreakData({
          ...updatedStreakData,
          isNewStreakDay: false, // Plus un nouveau jour apr√®s r√©clamation
          totalDodjiEarned: 0 // Plus de r√©compense √† r√©clamer
        });
      }
      
      return true;
    } catch (err: any) {
      console.error('üéØ useStreak: Erreur lors de la r√©clamation des r√©compenses:', err);
      setError(err.message || 'Erreur lors de la r√©clamation des r√©compenses');
      return false;
    } finally {
      setLoading(false);
    }
  }, [user, streakData, updateGlobalCache, getCurrentStreak]);

  /**
   * V√©rifie et met √† jour le streak (ancienne m√©thode pour compatibilit√©)
   */
  const checkStreak = useCallback(async () => {
    return await checkStreakEligibility();
  }, [checkStreakEligibility]);

  /**
   * Ferme le modal de streak
   */
  const closeModal = useCallback(() => {
    console.log('üéØ useStreak: Fermeture du modal');
    setModalData(prev => ({ ...prev, visible: false }));
  }, []);

  /**
   * Affiche le modal de streak avec les informations actuelles (sans r√©compense)
   */
  const showStreakInfo = useCallback(async () => {
    if (!user) {
      setError('Utilisateur non connect√©');
      return;
    }

    try {
      // R√©cup√©rer les donn√©es actuelles du streak
      const currentStreakData = await getCurrentStreak();
      if (currentStreakData) {
        const modalData = {
          visible: true,
          streakCount: currentStreakData.currentStreak,
          dodjiEarned: 0, // Pas de r√©compense lors d'un affichage manuel
          title: 'Votre streak de connexion',
          description: `Vous vous √™tes connect√© ${currentStreakData.currentStreak} jour${currentStreakData.currentStreak > 1 ? 's' : ''} cons√©cutif${currentStreakData.currentStreak > 1 ? 's' : ''} !`,
          isNewRecord: false
        };
        
        console.log('üéØ useStreak: Affichage manuel du modal de streak:', modalData);
        setModalData(modalData);
      }
    } catch (err: any) {
      console.error('üéØ useStreak: Erreur lors de l\'affichage du modal de streak:', err);
      setError(err.message || 'Erreur lors de l\'affichage des informations de streak');
    }
  }, [user, getCurrentStreak]);

  /**
   * V√©rifie si l'utilisateur peut gagner un streak aujourd'hui
   */
  const canEarnStreakToday = useCallback(async () => {
    if (!user) {
      setError('Utilisateur non connect√©');
      return false;
    }

    try {
      setError(null);
      return await StreakService.canEarnStreakToday(user.uid);
    } catch (err: any) {
      setError(err.message || 'Erreur lors de la v√©rification du streak quotidien');
      return false;
    }
  }, [user]);

  /**
   * R√©initialise le streak (pour les tests)
   */
  const resetStreak = useCallback(async () => {
    if (!user) {
      setError('Utilisateur non connect√©');
      return;
    }

    try {
      setLoading(true);
      setError(null);
      await StreakService.resetStreak(user.uid);
      // Rafra√Æchir les donn√©es apr√®s la r√©initialisation
      await getCurrentStreak();
      hasCheckedForNewLoginRef.current = false; // Permettre une nouvelle v√©rification
    } catch (err: any) {
      setError(err.message || 'Erreur lors de la r√©initialisation du streak');
    } finally {
      setLoading(false);
    }
  }, [user, getCurrentStreak]);

  // D√©tecter les nouvelles connexions et v√©rifier l'√©ligibilit√© au streak
  useEffect(() => {
    const currentUserId = user?.uid || null;
    const previousUserId = previousUserRef.current;

    console.log('üéØ useStreak: Effet de d√©tection de connexion:', {
      currentUserId,
      previousUserId,
      hasCheckedForNewLogin: hasCheckedForNewLoginRef.current,
      isCheckingEligibility: isCheckingEligibilityRef.current,
      globalCache: globalEligibilityCache
    });

    // Si l'utilisateur vient de se connecter (passage de null √† un utilisateur)
    if (currentUserId && !previousUserId) {
      // V√©rifier le cache global d'abord
      if (isGlobalCacheValid(currentUserId)) {
        console.log('üéØ useStreak: Cache global valide, pas de nouvelle v√©rification n√©cessaire');
        hasCheckedForNewLoginRef.current = true;
        return;
      }

      // V√©rifier les protections locales et globales
      if (!hasCheckedForNewLoginRef.current && !isCheckingEligibilityRef.current && !globalEligibilityCache.isChecking) {
        console.log('üéØ useStreak: Nouvelle connexion d√©tect√©e, v√©rification de l\'√©ligibilit√© au streak');
        
        // Attendre un peu pour que la navigation soit termin√©e
        setTimeout(() => {
          // V√©rifier √† nouveau que la v√©rification n'est pas d√©j√† en cours
          if (!hasCheckedForNewLoginRef.current && !isCheckingEligibilityRef.current && !globalEligibilityCache.isChecking) {
            checkStreakEligibility().then(() => {
              hasCheckedForNewLoginRef.current = true;
            });
          } else {
            console.log('üéØ useStreak: V√©rification d√©j√† effectu√©e ou en cours, ignor√©');
          }
        }, 1000); // D√©lai de 1 seconde pour laisser la navigation se terminer
      } else {
        console.log('üéØ useStreak: V√©rification d√©j√† effectu√©e ou en cours, ignor√©');
      }
    }

    // Si l'utilisateur se d√©connecte
    if (!currentUserId && previousUserId) {
      console.log('üéØ useStreak: D√©connexion d√©tect√©e, r√©initialisation de l\'√©tat');
      hasCheckedForNewLoginRef.current = false;
      isCheckingEligibilityRef.current = false;
      
      // R√©initialiser le cache global si c'est le m√™me utilisateur
      if (globalEligibilityCache.userId === previousUserId) {
        globalEligibilityCache = {
          userId: null,
          timestamp: 0,
          isChecking: false,
          hasCheckedToday: false
        };
      }
      
      setStreakData(null);
      setModalData({
        visible: false,
        streakCount: 0,
        dodjiEarned: 0,
        title: '',
        description: ''
      });
    }

    // Mettre √† jour la r√©f√©rence
    previousUserRef.current = currentUserId;
  }, [user, checkStreakEligibility, isGlobalCacheValid]);

  // Charger les donn√©es de streak au montage du composant si l'utilisateur est d√©j√† connect√©
  useEffect(() => {
    if (user && !streakData && hasCheckedForNewLoginRef.current) {
      console.log('üéØ useStreak: Chargement initial des donn√©es de streak');
      getCurrentStreak();
    }
  }, [user, streakData, getCurrentStreak]);

  return {
    streakData,
    modalData,
    loading,
    error,
    checkStreak,
    checkStreakEligibility,
    claimReward,
    getCurrentStreak,
    canEarnStreakToday,
    resetStreak,
    closeModal,
    showStreakInfo
  };
}; 